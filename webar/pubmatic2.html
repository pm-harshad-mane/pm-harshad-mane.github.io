<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>PubMatic — Anchored Markerless WebAR</title>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
<style>
  html, body { margin:0; height:100%; overflow:hidden; background:transparent; }
  canvas { background: transparent !important; } /* show camera passthrough */
  #startOverlay {
    position: fixed; inset: 0; display: grid; place-items: center;
    background: #000; color: #00FFFF; font-family: system-ui, -apple-system, sans-serif;
    font-size: 20px; letter-spacing: .4px; z-index: 10; text-align: center;
  }
  #startOverlay .btn {
    border: 1px solid #00FFFF; padding: 14px 22px; border-radius: 12px; margin-top: 12px;
    display: inline-block;
  }
  #errorBox {
    position: fixed; left: 12px; right: 12px; bottom: 12px;
    background: rgba(0,0,0,.7); color:#fff; padding:10px 12px; border-radius:10px;
    font: 14px system-ui, -apple-system, sans-serif; display:none; z-index: 11;
  }
</style>
</head>
<body>

<div id="startOverlay">
  <div>
    <div>Tap to start AR</div>
    <div class="btn">Launch</div>
  </div>
</div>
<div id="errorBox"></div>

<a-scene
  embedded
  renderer="alpha:true; antialias:true; physicallyCorrectLights:true; colorManagement:true"
  xr-mode-ui="enabled:false"
  webxr="mode: ar; requiredFeatures: local-floor; optionalFeatures: hit-test"
  vr-mode-ui="enabled:false"
>
  <!-- Camera -->
  <a-entity id="cameraRig">
    <a-entity id="camera" camera look-controls></a-entity>
  </a-entity>

  <!-- Lighting -->
  <a-entity light="type: ambient; intensity: 1"></a-entity>

  <!-- PubMatic text (hidden until placed) -->
  <a-entity id="pubText"
    text="value: PubMatic; color: #00FFFF; align: center; width: 2.8; anchor: center; baseline: center"
    visible="false"
    scale="1.4 1.4 1.4">
  </a-entity>
</a-scene>

<script>
const scene   = document.querySelector('a-scene');
const overlay = document.getElementById('startOverlay');
const errBox  = document.getElementById('errorBox');
const pubText = document.getElementById('pubText');

function showError(msg) {
  errBox.textContent = msg;
  errBox.style.display = 'block';
}

async function startAR() {
  try {
    if (!('xr' in navigator)) {
      showError('WebXR not available in this browser.');
      return;
    }
    const supported = await navigator.xr.isSessionSupported('immersive-ar');
    if (!supported) {
      showError('Immersive AR not supported on this device/browser.');
      return;
    }

    overlay.style.display = 'none';

    // Request AR session directly (works reliably on iOS Safari)
    const session = await navigator.xr.requestSession('immersive-ar', {
      requiredFeatures: ['local-floor'],
      optionalFeatures: ['hit-test']
    });

    // Hand the session to A-Frame’s renderer
    const renderer = scene.renderer;
    renderer.xr.setReferenceSpaceType('local-floor');
    await renderer.xr.setSession(session);

    // Try hit-test to anchor on a real surface; fallback if no result
    let placed = false;
    try {
      const viewerSpace = await session.requestReferenceSpace('viewer');
      const localSpace  = await session.requestReferenceSpace('local-floor');
      const hitSource   = await session.requestHitTestSource({ space: viewerSpace });

      let frames = 0;
      renderer.setAnimationLoop((t, frame) => {
        if (placed || !frame) return;
        const results = frame.getHitTestResults(hitSource);
        if (results && results.length) {
          const pose = results[0].getPose(localSpace);
          if (pose) {
            const p = pose.transform.position;
            pubText.object3D.position.set(p.x, p.y + 0.02, p.z);
            // Face the camera once
            const cam = scene.camera;
            if (cam) pubText.object3D.lookAt(cam.getWorldPosition(new THREE.Vector3()));
            pubText.setAttribute('visible', 'true');
            placed = true;
          }
        }
        // ~1s grace period for hit-test; then fallback
        if (!placed && ++frames > 60) {
          fallbackPlace();
          placed = true;
        }
      });
    } catch (e) {
      // Hit-test path failed — fallback immediately
      fallbackPlace();
    }

    // Clean up loop on session end
    session.addEventListener('end', () => {
      try { renderer.setAnimationLoop(null); } catch {}
    });

  } catch (e) {
    console.error(e);
    showError('Could not start AR session. Ensure HTTPS and Safari iOS 17+.');
  }
}

function fallbackPlace() {
  const cam = scene.camera; if (!cam) return;
  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(cam.quaternion).normalize();
  const pos = cam.getWorldPosition(new THREE.Vector3());
  const target = pos.clone().add(dir.multiplyScalar(1.5));
  target.y = Math.max(target.y, pos.y - 0.1);
  pubText.object3D.position.copy(target);
  pubText.object3D.lookAt(pos);
  pubText.setAttribute('visible', 'true');
}

const once = { once: true };
overlay.addEventListener('click', startAR, once);
overlay.addEventListener('touchstart', (e) => { e.preventDefault(); startAR(); }, once);
</script>
</body>
</html>
